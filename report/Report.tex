\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{url}
\usepackage{seqsplit}
\hypersetup{pdfstartview={FitH null null null}}
\usepackage{amssymb,amsmath}
\usepackage{amsthm}
\usepackage{empheq}
\usepackage{algorithm,algpseudocode}
\usepackage[margin=1.5in]{geometry}
\usepackage{listings}
\usepackage{program}
\usepackage{commath}
\lstset{language=Python} 

\usepackage{listings}
\usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}


\title{Stochastic optimization of an objective function to build a 3D chromosomal model}
\author{Caiwei Wang, Xiaokai Qian, Sean Lander, \\Haipei Fan, Puneet Gaddam, Brett Koonce\\\\University of Missouri - Columbia}

\date{May 7, 2014}

\algloopdefx{NoEndIf}[1]{\textbf{If} #1 \textbf{then}}

\begin{document}

\maketitle

\section{Abstract}

First, we construct a congugate gradient (CG) descent searcher to build a 3D model of a human chromosome using the method advanced by Trieu and Cheng in a recent paper.  Next, we utilize two different stochastic methods, simulated annealing (SA) and Markov-Chain Monte-Carlo (MCMC), to duplicate our CG results.  Then, we build a PDB model of the final chromosome and visualize the process of solving the objective function.  Ultimately, we compare our results with other research in this domain, discuss difficulties we encountered and potential future improvements that could be made.

\section{Introduction}

The human genome has been sequenced, but modelling the human chromosome remains a difficult task.  One promising avenue of modern research lies in the technique of Hi-C sequencing, which produces contact maps as part of the sequencing process.  By analyzing which regions of the genome are often found together, we can build up a map of the larger genome.  Trieu and Cheng recently proposed a new method based on an objective function that promises to be able to build a model using gradient descent from the Hi-C data.  We decided to put their results to the test, as well as experiment with solving the objective function using stochastic (MCMC and SA) methods.

\section{Overview}



\section{Dataset}

We obtained a megabase resolution fragment database (157x157, dropping first/last residues from Chromosome 7) from Trieu to work with.  We set all entries less than 0.66 to 0, as per the same treatment in the original paper.  We also made a list of the constants they used, so that our results would match.

\section{Objective function}

Simply put, the objective function advanced by Trieu and Cheng can be expressed as follows:

\begin{equation}
      TotalModelScore(m) = ContactScore(m) + NonContactScore(m) + PairSmoothing(m)
\end{equation}

The first operation minimizes the distances of contacts with affinity to keep them in contact (but keeps their distance above a minimum threshold):

\begin{equation}
      ContactScore(m) = \sum_{i=1}^{n} \sum_{j=1}^{n} (\abs{i-j}>1) * (W_1 * \tanh(d_c^2-d_{ij}^2) * N_{ij} + W_2 * \tanh(d_{ij}^2-d_{min}^2))
\end{equation}

The second operation maximizes the distances of contacts without affinity to keep them away from contact (but keeps their distance below a maximum threshold):

\begin{multline}
      NonContactScore(m) = \sum_{i=1}^{n} \sum_{j=1}^{n} (\abs{i-j}>1) * (W_3 * \tanh(d_{max}^2-d_{ij}^2) / totalIF \\+ W_2 * \tanh(d_{ij}^2-d_{c}^2) / totalIF)
\end{multline}

The third operation tweaks the scores of consecutive contacts slightly so that moving them is favored during gradient descent:

\begin{multline}
      PairSmoothing(m) = \sum_{i=1}^{n} \sum_{j=1}^{n} (\abs{i-j}=1) * (W_1 * IF_{max} / totalIF * \tanh(da_{max}^2-d_{ij}^2) \\+ W_2 * \tanh(d_{ij}^2-d_{min}^2) / totalIF)
\end{multline}

We also used the following table of constants from Trieu and Cheng's paper.  They are experimentally derived values.

\begin{center}
\begin{tabular}{|l|c|c|c|r|}
\multicolumn{4}{c}{Constants} \\
    \hline
    $d_{min}$ & 1 & W1 & 1.0           \\ \hline
    $d_{max}$ & 4.5  & W2 & 1.5      \\ \hline
    $d_{c}$ & $\sqrt 7.0$  & W3 & 1.5            \\ \hline
    $da_{max}$ & $\sqrt 1.8$  & W4 & 1.5     \\ \hline
    \end{tabular}
\end{center}

We also make use of the following:

\begin{equation}
      TotalIF = sum(input IF matrix)
\end{equation}

\begin{equation}
      N(i,j) = IF(i,j)/TotalIF
\end{equation}

\begin{equation}
      IF_{max} = max(IF(i,j),IF(j,i))
\end{equation}

Combining the above equations, we end up with a combined objective function of approximately 50000 subproblems, as detailed above.  Our problem now is simply to maximize the result given a 471 variable input vector (157 contacts * 3 coordinates (x,y,z)) across this space.  Towards this end, we present one deterministic and two stochastic methods of optimization.  For each version, our initial problem subspace is randomly chosen coordinates in the domain $-0.5 =< (x, y, z) <= 0.5$. 

\section{Conjugate Gradient Descent}

Our first method we applied is standard gradient descent.  We utilized a solver based upon the Powell conjugate method.  This allowed us to avoid calculating a derivative function.  Instead, it maintains a list of search vectors and attempts a bidirectional search along each one.  Each iteration, the highest performing vector is replaced by the best new search vector and then the process repeats.  This method is easy to implement, but takes some time to run.

\section{Simulated Annealing}

For our first test of stochastic methods, we built a simulated annealer capable of solving our objective function.  SA is a well known non-deterministic algorithm to sample a state space quickly.  Essentially, we start from a random model, then generate a neighboring model (our original model with a modification).  We score the two models.  If the new one is better, we accept it, otherwise we only replace our existing model based on a gradually decreasing schedule (temperature function).  As such, the two most important parts of implementing simulated annealing are the temperature function and how we generate neighbor models.

We tested the following two temperature functions, one sigmoid and one linear:

\begin{equation}
      T_s(e,t,k) =  -t*2/(1 + math.exp(-5*k/t)) + t*2
    \end{equation}
\begin{equation}
      T_l(e,t,k) =  (-t/e)*k + t
    \end{equation}
    
For a neighborhood function, we selected a contact at random and moved it a random amount.

\section{Markov-Chain Monte-Carlo}

For our second test of stochastic methods, we built a Markov-Chain Monte Carlo sampler.

\section{Results}



\section{Visualization}



\section{Citations}

We thank the following tools and papers: \\

Tuan Trieu and Jianlin Cheng.  Large-scale reconstruction of 3D structures of human chromosomes from chromosomal contact data.  Nucl. Acids Res. first published online January 24, 2014. doi:10.1093/nar/gkt1411


\section{Visualization}



\end{document}
